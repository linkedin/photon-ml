apply plugin: 'li-scala'
apply plugin: 'li-integ-test'

integTest {
  useTestNG()

  afterSuite { desc, result ->
    if (!desc.parent) {
      println ":${project.name} -- Executed ${result.testCount} tests: ${result.successfulTestCount} succeeded, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped"
    }
  }

  // Forward standard out from child JVMs to the console
  systemProperty "log4j.configuration", "file:${project.rootDir}/log4j.properties"

  minHeapSize = "2G"
  maxHeapSize = "8G"

  maxParallelForks = 4
  forkEvery = 0

  options {
    parallel = 'methods'
    threadCount = 1
  }
}

compileScala {
  scalaCompileOptions.fork = true
  scalaCompileOptions.additionalParameters = [
    "-feature",
    "-language:reflectiveCalls", // used for config structural typing
    "-language:postfixOps"
  ]
}

dependencies {
  compile(spec.external."scalaCompiler$scalaSuffix")
  compile(spec.external."scalaLibrary$scalaSuffix")
  compile(spec.external."scalaReflect$scalaSuffix")
  compile(spec.external.avro)
  compile(spec.external.avroCompiler)
  compile(spec.external.avroMapred)
  compile(spec.external.xchart)
  compile(spec.external.batik)

  compile(spec.external."spark-core$scalaSuffix")
  compile(spec.external."spark-mllib$scalaSuffix")
  compile(spec.external."spark-sql$scalaSuffix")
  compile(spec.external."spark-catalyst$scalaSuffix")

  //this one is scala's option parsing library
  compile(spec.external."scopt$scalaSuffix")

  compile(spec.external."log4j")

  compile(spec.product."photon-schemas"."photon-schemas")


  testCompile(project(":photon-test$scalaSuffix"))
  testRuntime(spec.external."breeze-core$scalaSuffix")
  testRuntime(spec.external."breeze-macro$scalaSuffix")
}
